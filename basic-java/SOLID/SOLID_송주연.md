# SOLID 원칙



**SOLID 원칙**

소프트웨어를 설계하는 5개의 원칙 

**디자인 패턴**

+ 많은 프로그래머들이 성공적인 프로젝트에서 무수히 반복해 사용했던 문제해결 기술을 발견해 정형화 한 것
+ 각 패턴은 특정 맥락의 문제를 효과적으로 해결할 수 있게 해준다
+ good game이 될 수 있었던 법칙을 특정 문제에 따라 정형화 한 것 



**SOLID 원칙**

+ 게임의 법칙



## SRP: 단일 책임의 원칙

> Single Responsibility Principle



하나의 클래스에 변경을 위한 두가지 이상의 이유가 있다면 그 클래스는 한가지 이상의 책임을 갖고 있는 것이다. 

1. 하나의 클래스는 하나의 기능 
   + `하나` 라는 기준이 모호, `하나` 의 기준을 어떻게 정의해야 할까?
2. 중요한 기준은 **변경** 에 있다. 코드를 변경했을때 파급효과가 적다면 단일책임 원칙을 잘 따른 설계라고 볼 수 있다. 





> 참고자료
>
> + https://github.com/cheese10yun/spring-SOLID/blob/master/docs/SRP.md



---



## OCP: 개방 폐쇄의 원칙

> Open Close Principle



소프트웨어 구성요소는 확장에 대해서는 개방되어야 하지만 변경에 대해서는 폐쇄되어야 한다. 

기존의 코드를 변경하지 않으면서 기능을 추가할 수 있도록 설계가 되어야 한다. 

**핵심은 <u>Close</u>**



### OCP 적용 방법

1. 변경될 것과 변하지 않을 것을 명확히 구분
   + 역할과 배우를 명확하게 구분하기 
2. 1에서 구분한 모듈이 만나는 지점에 인터페이스를 정의
3. 구현에 의존하기보단 정의한 인터페이스에 의존하도록 코드 작성
   +  **DI**: 생성되는 시점에서 구현 클래스를 외부에서 주입



**기존의 코드를 변경하지 않으면서 기능을 추가할 수 있다. **



> 참고 자료
>
> + https://dublin-java.tistory.com/47
> + https://dublin-java.tistory.com/48?category=680842





---



## LSP: 리스코브 치환의 법칙

> The Liskov Substitution Principle

**기능확장** 과 **함수의 명세** 와 관련된 원칙 





상위타입의 객체를 하위 타입의 객체로 치환해도 상위 타입을 사용하는 프로그램은 정상적으로 동작해야함 

+ *B가 A의 자식이면 A객체를 B로 치환해도 작동에 문제가 없어야 한다.*

OCP는 추상화와 다형성을 이용해서 구현됨, LSP는 OCP를 받쳐주는 다형성에 대한 원칙을 제공한다. 

(LSP원칙을 어기면 OCP 원칙을 위반할 가능성이 높아진다. )

이 원칙은 자식 클래스를 구현하는 개발자가 기존 프로그램이 문제없이 안정적으로 작동할 수 있도록 가이드라인을 알려주는 원칙 



### 대표적 예시: 직사각형과 정사각형 



1. 정사각형 클래스가 직사각형 클래스를 상속함 

2. 정사각형 클래스에서 '네 변의 길이가 동일하다' 라는 함수를 구현

3. 직사각형 객체의 넓이를 구하고자 할때 정사각형 클래스를 치환해서 사용하면 에러 발생 

   ==> LSP 원칙에 어긋남 



### LSP 원칙에서 강조하고자 하는 점 

부모 클래스 타입의 객체가 사용하는 기존의 프로그램 코드에 자식 클래스 객체를 대입시켰을때도 문제없이 작동하도록 하려면 <u>자식 클래스는 부모 클래스가 따르던 계약 사항을 잘 따르도록 만들어져야 한다.</u>



> 참고자료
>
> +  https://pizzasheepsdev.tistory.com/9
> + https://4z7l.github.io/2021/05/31/SOLID_LSP.html



---



## ISP: 인터페이스 분리 원칙

> Interface Segregation Principle 



**인터페이스 분리 원칙**이란 **객체는 자신이 호출하지 않는 메소드에 의존하지 않아야 한다. **



객체가 반드시 필요한 기능만을 가지도록 제한하는 원칙

불필요한 기능의 상속/구현을 최대한 방지함으로써 객체의 불필요한 책임을 제거한다. 

큰 규모의 객체는 필요에 따라 인터페이스로 잘게 나눠 확장성을 향상시킨다. 



> 참고자료
>
> + https://blog.itcode.dev/posts/2021/08/16/interface-segregation-principle



---

## DIP: 의존성 역전의 원칙 

> Dependency Inversion Principle



상위 수준 정책은 하위 수준 세부정보에 의존해서는 안된다.

+ 



> 참고자료
>
> + https://github.com/cheese10yun/spring-SOLID/blob/master/docs/DIP.md
