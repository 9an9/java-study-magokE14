# Design Pattern
  : 일종의 설계 기법이며, 설계 방법이다.
  
# 목적
  : SW 재사용성, 호환성, 유지 보수성을 보장.
  
# 특징
  : 디자인 패턴은 특정한 구현이 아닌 하나의 아이디어.
  
  프로젝트에 항상 적용해야 하는 것은 아니지만, 추후 (재사용, 호환, 유지 보수시) 발생하는 문제해결을 예방하기 위해 패턴을 만들어 둔 것.
  
# SOLID 객체지향 설계 원칙

  1. Single Responsibility Principle(단일 책임 원칙)
    하나의 클래스는 하나의 역할만을 가지도록 설계해야 한다.
    어떤 클래스를 변경해야 하는 이유는 오직 하나뿐이어야 한다.
    (책임 = 변경사유, 해야하는일)
    같은 이유로 변화하는 것끼리 묶고, 다른 이유로 변화하는 것끼리는 분리하라.
    (응집도를 높이면서 결합도는 낮추는)
    ```
    public class Student { 
    public void getCourses() { ... } 
    public void addCourse(Course c) { ... } 
    public void save() { ... } 
    public Student load() { ... } 
    public void printOnReportCard() { ... } 
    public void printOnAttendanceBook() { ... } }
    ```
    
    ```
    public class Student { 
    public void getCourses() { ... } 
    public void addCourse(Course c) { ... } }
    ```
    
    수강과목(Course)을 불러오고 조회하는 책임만을 부여하여 SRP를 적용시킨다.
    Student 클래스가 수정되어야 한다면 그 사유는 수강과목을 조회하고 불러오는 일과 관련되어야 한다.
    
    
  2. Open Close Principle (개방 폐쇄 원칙)
    확장 (상속)에는 열려있고, 수정에는 닫혀 있어야 한다.
    기존의 코드를 변경하지 않으면서 새로운 기능을 추가할 수 있도록 설계하는 원칙.
    
    무엇이 변하는 것인지, 무엇이 변하지 않는 것인지를 구분하여,
    변해야 하는 것은 쉽게 변할 수 있게 하고
    변하지 않아야 할 것은 변하는 것에 의해 영향을 받지 않게 해야 한다.
    
    ```Java
    public class Student { 
    public void getCourses() { ... } 
    public void addCourse(Course c) { ... } }
    ```
    
    수강과목을 추가할때 담당교수에게 메일이 가도록 추가하고 싶다면?
    
    Student 클래스의 코드를 수정하는 것보다,
    애초에 생성할때 추상클래스(추상메소드 포함)로 선언해 주는것이 좋다.
    그래야 추가기능을 넣어주고 싶을때 이를 확장하여 기존의 코드를 건드는 일이 없음.
    
    ```Java
    public abstract class Student { 
    public void getCourses() { ... } 
    public abstract void addCourse(Course c) { ... } }
    ```
    
    ####<클래스를 변경하지 않고도(closed) 그 클래스를 둘러싼 환경을 변경할 수 있는(open) 설계.>
    
  3. Liskov Substitution Principle (리스코프 치환 원칙)
    (상속관계에서) 자식이 부모의 자리에 항상 교체될 수 있어야 한다.
    부모 클래스와 자식 클래스 사이의 행위가 일관성이 있어야 한다.
    
    ```java
    public class Rectangle {
    protected double width;
    protected double height;

    public double getWidth() {
        return width;
    }

    public void setWidth(final double width) {
        this.width = width;
    }

    public double getHeight() {
        return height;
    }

    public void setHeight(final double height) {
        this.height = height;
    }

    public double getArea() {
        return width * height;
    }
}
```


  4. Interface Segregation Principle(인터페이스 분리 원칙)
    인터페이스가 잘 분리되어서, 클래스가 꼭 필요한 인터페이스만 구현하도록 해야한다.
    
  5. Dependency Inversion Property(의존성 역전 원칙)
    의존 관계를 맺을 때 변화하기 쉬운 것 또는 변화가 자주 되는것보다는 
    변화하기가 어려운 것, 변화가 거의 되지 않는 것에 의존하는 원칙
    
    상위 모듈이 하위 모듈에 의존하면 안되고 추상화에 의존하며,
    추상화는 세부사항에 의존하면 안된다.
    
    참고자료 : https://gyoogle.dev/blog/design-pattern/Overview.html
