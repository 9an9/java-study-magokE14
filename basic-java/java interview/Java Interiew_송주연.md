# Java Interview



> 자바 기술면접 질문리스트



### 1. 클래스와 객체의 차이

객체는 관념적인 것, 소프트웨어 세계에서 구현할 대상 

클래스는 객체를 구현하기 위해서 만들어진 틀, blueprint

클래스는 메소드와 변수로 구성된다. 





### 2. 객체와 인스턴스의 차이는 무엇인가?



인스턴스는 클래스로 만들어낸 대상, 실제로 메모리에 할당된 객체

객체는 인스턴스와 동일한 의미로 사용되긴 하지만 좀 더 관념적인 단어 



> 덧, 객체지향에 대하여 
>
> 자전거를 만들고자 한다. 자전거라는 관념은 객체라고 한다면 자전거의 행위, 자전거의 구성품 등 
> 메소드와 변수로 자전거의 설계도를 구현한 것을 클래스라고 한다. 
>
> 그리고 클래스로 찍어낸 삼천리자전거, 따릉이 등은 인스턴스다. 
> 이미 만들어진 자전거 클래스를 확장해서 산악자전거, 경주용 자전거 등 여러가지 다양한 자전거를 만들 수도 있다. 
>
> 그것이 바로 객체지향적 프로그래밍 



### 3. Call by value와 Call by reference의 차이



함수의 호출방식, 함수가 호출될때 stack에 공간이 할당되고 함수가 끝이 나면 해당 공간은 사라진다. 

하지만 call by value, call by reference 둘 중 어느 방식으로 호출됨 따라 함수 종료 후 결과가 달라진다. 

+ call by value
  + 함수 파라미터로 전달된 변수의 값과 같은 값을 복사해서 함수 호출 stack에 저장 
  + 함수 호출이 끝나면 자연스럽게 사라지고 파라미터로 넣어진 변수의 값도 변화가 없다. 
  + 장점
    + 원본 변수의 값이 변하지 않는다.
  + 단점
    +  변수의 값을 복사해야 하기 때문에 시간이 오래 걸린다. 메모리 사용량이 늘어난다. 
+ call by reference
  + 함수 파라미터로 전달된 변수의 주소를 참조한다. 따라서 함수 안에서 파라미터의 값이 변했으면 실제 변수의 값도 변한다. 
  + 장점
    + 직접 참조를 하기 때문에 빠르다 
  + 단점
    + 원본 값이 영향을 받을 수 있기때문에 리스크가 있다. 



e.g)

```java
// call by val
int a = 3;
int b = a;
b = 4;
System.out.printf("a: %d, b: %d\n", a, b); // a: 3, b: 4

// call by ref
int[] arr1 = {1,2,3,4};
int[] arr2 = arr1;
arr2[0] = 7;
System.out.println(arr1[0]); // 7
System.out.println(arr2[0]); // 7
```



### 4. Primitive type 과 Reference type의 차이

+ 원시타입
  + 컴파일 과정에서 할당
  + Null을 가질 수 없음
  + 실제 값이 저장됨 
  + 한번 할당한 뒤로 값 변경 불가, 새로 주소할당 해야함 
+ 참조타입 
  + 런타임 과정에서 할당
  + Null을 가질 수 있음
  + 한번 할당한 뒤로 값 변경 가능 , 주소 그대로 

### 5. 오버로딩과 오버라이딩?

둘 다 다형성 측면에서 사용된다는 점에서 동일함 



+ 오버로딩

  + 함수 이름과 리턴타입은 같지만 파라미터를 다르게 하는 것 

+ 오버라이딩 

  + 상속하는 클래스의 함수를 재정의 하는 것

  

### 6. 추상 클래스와 인터페이스의 차이

 인터페이스와 추상클래스 모두 추상 메소드를 가진다. 그리고 구현하는 클래스가 추상 메소드를 구현할 것을 강제한다. 

인터페이스는 다중 상속(implements)이 가능하고 클래스는 단일 상속(extends)만 할 수 있다. 

이런 이유로 추상 클래스는 클래스의 아이텐티티를 정의할 때 사용되고, 인터페이스는 클래스의 기능을 정의할 때 사용된다. 



예를 들면 '갤럭시 s10e' 클래스를 구현하고자 할 때 갤럭시 추상 클래스를 상속받아 부모가 갤러시라는 클래스의 아이덴티티를 정의한 후 전화통화, 와이파이, 카메라 같이 클래스가 가지는 기능이나 특징은 인터페이스로 구현할 수 있다. 





### 7. StringBuilder와 StringBuffer의 차이

+ StringBuilder

  + 스트링 버퍼보다 빠름 
  + 단일 스레드에서 사용할때 

+ StringBuffer

  + 스트링 빌버보다 느림

  + 멀티 스레드에서 사용할때 

    

### 8. 오토 박싱 & 오토 언박싱의 차이

원시타입을 참조타입, 참조타입을 원시타입으로 자동적으로 변환해주는 것 

+ boxing
  + primitive type ----> wrapper class
+ unboxing
  + wrapper class ----> primitive type



### 9. String a = “apple”, String b = new String(”apple”) 차이 

리터럴 변수는 스트링 풀에 저장됨. 

String a = "hi";

String a2 = "hi" 일 경우 a2는 새롭게 공간을 할당하는 것이 아니라 스트링 풀에서 "hi"가 있는 공간을 찾아서 그 공간을 가리킴 , a와 a2는 같은 문자열 참조 



new로 생성된 변수는 같은 값을 가져도  새로운 공간 할당



#### 언제 어떤것들을 써야 할까?

+ 리터럴 
  + 변수들이 중복된 값을 가질 경우 사용하는 게 좋음 
  + e.g) a = "LG CNS", b = "LG CNS", c = "LGE", d = "LGE " 등 
+ new







> 참고
>
> + https://madplay.github.io/post/java-string-literal-vs-string-object
>
>   





